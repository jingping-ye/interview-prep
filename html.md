HTML
=====

## 浏览器渲染过程
> 四个步骤。打油诗曰:先是生成DOM树，再次生成规则树，二者合为渲染树，遍历计算树节点，绘制节点至屏幕。
- 解析html生成DOM树
- 解析css生成cssDOM规则树
- 将html DOM树和cssDOM规则树合并在一起，生成渲染树
- 遍历渲染树，开始布局，计算渲染书节点的大小和位置
- 将每个节点绘制到屏幕上

----------

## 语义化
> 3个方向:何为语义化，如何语义化，语义化的好处
### 什么是语义化
使用带有清晰含义、符合内容的标签去展示内容。
### 如何实现语义化
使用header、footer、article、nav等标签。
### 语义化的好处
- 易于用户阅读，即使样式丢失，也能较好的展示页面
- 便于屏幕阅读器等辅助工具，帮助阅读障碍人群阅读
- 程序较为请求，有利于后期网站的维护
- 便于seo和搜索引擎根据标签确定关键字的权重

----------

### img中title和alt的区别
- title:鼠标移上去显示的文字，也可用于其他标签
- alt 图片丢失时显示的文字

----------

## src和href的区别
- src用于引进图片、外部js脚本等资源。浏览器解析时，遇到src标签将会暂停其他资源的下载和处理，一直到资源加载、编译、执行完毕。
- href用于外部链接、外部css样式文件等资源。浏览器对外部css文件解析时，会并行下载其他资源。

----------

## reflow和repaint
> 3个方向:是什么、怎么引起的、怎样降低影响
### reflow和repanit是什么
- reflow
	当DOM节点的布局属性(位置和大小)发生变化时，浏览器会重新描绘该属性，这就叫做重排(reflow)。
- repaint
	当DOM节点的可见性属性发生改变时，浏览器会重新绘制该节点，这就叫做重绘(repaint)。
PS:重排必然会引起重绘。
### 什么操作会引起reflow和repaint？
- 调整浏览器窗口的大小
- 进行删减、添加元素的DOM操作
- 字体大小和样式的改变
- 元素内容发生改变，尤其是输入控件
- hover等动作产生的用户交互行为
- width、clientWidth、scrollTop等计算行为
### 如何降低reflow和repaint对性能的影响
- 使用class统一改变样式，避免逐条改变样式。
- 避免clientWidth和scrollTop的频繁操作。
- 对需要的元素使用绝对定位脱离文档流，避免父元素和后续元素的大量回流。
- 避免频繁的DOM操作。

----------

## viewport属性
* width	设置layout viewport 的宽度，为一个正整数，或字符串"width-device"
* initial-scale	设置页面的初始缩放值，为一个数字，可以带小数
* minimum-scale	允许用户的最小缩放值，为一个数字，可以带小数
* maximum-scale	允许用户的最大缩放值，为一个数字，可以带小数
* height	设置layout viewport 的高度，这个属性对我们并不重要，很少使用
* user-scalable	是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。

----------

## 渐进式渲染
> 2个方向:什么是渐进式渲染,如何实现渐进式渲染
### 什么是渐进式渲染
渐进式渲染(progressive rendering)是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。
### 如何实现渐进式渲染
* 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。
* 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听`DOMContentLoaded`/`load`事件加载其他资源和内容。
* 异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在[这里](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/)找到。


----------

## link和script在浏览器中的位置
link放在文档开头的head标签中，script防止在body标签结束时。原因，css文件是对页面样式的描述，先加载css，可以给用户呈现一个体验感更高的网页。script文件大多数时候是一些用户和网站之间的交互函数，script加载时，会阻塞浏览器加载其他的网页资源，这样，可能会产生一个空白的页面给用户。script中如果要进行dom操作，也要依赖于body中的html代码。所以，先加载css资源，最后再加载script资源。


----------

## cookie、localStorage、sessionStorage的异同
### 相同点
- 都是客户端存储机制
- 数据都是以键值对的形式存储在客户端
- 存储的数据都为字符串
### 不同点
- 存储的大小:cookie为4kb,localStorage和sessionStorage为5M.
- 有效期:cookie为手动设置的时间;localStorage一直存在，直至浏览器清理掉缓存;sessionStorage为页面关闭时
- 服务器是否可以直接访问和设置:cookie可以，其余二者不可.
- 访问权限:cookie和localStorage为域名下的任意窗口,sessionStorage为当前页面
- 在浏览器会话的期间是否会更改:cookie取决于是否设置过期时间,localStorage不会更改,sessionStorage则会更改。
### 如何设置
- cookie:document.cookie="userId=828; userName=hulk";
- localStorage: localStorage.setItem("username","hulk");
- sessionStorage: sessionStorage.setItem("username","hulk");


----------

## doctype的作用
- 声明文档:声明html页面是用哪个版本的html进行编写的
- 告知解析器采用什么DTD(文档类型定义)来解析html文档

----------
## 兼容性问题
> 2个方向:兼容性问题产生的原因、如何解决兼容性问题；解决问题又分为:要不要做，要做的话做到什么程序、怎么做。
### 产生原因
- 无统一的浏览器:浏览器产商根据自己对浏览器的需求开发不同的浏览器、浏览器功能不一
- 浏览器版本:用户使用的浏览器版本不一:有的使用版本较新，有的使用版本较老。
### 如何解决兼容性问题
#### 要不要做
- 产品的目标客户：大部分目标用户使用的浏览器版本、对产品本身的要求(是以功能为主，还是以呈现页面为主)
- 成本:投入产出比是否高，是否有盈利的空间
#### 做到什么程序
- 需要支持什么浏览器
- 浏览器要支持到哪个版本
#### 怎么做
- 根据兼容性要求选择相应的库
- 使用兼容性工具，比如(html5shiv.js、respond.js、css reset、normalize.css、Modernizr)
- 条件注释、CSS Hack、js 能力检测做一些修补
- 渐进增强和优雅降级
	- 渐进增强:先针对低版本浏览器做开发，保证一些基本的需求，然后再对高浏览器进行交互、效果等功能的改进，以期达到提高用户体验的要求。
	- 优雅降低:按照版本高的浏览器进行完整功能的开发，再按照需要兼容的低版本浏览器，进行功能和效果的改进
